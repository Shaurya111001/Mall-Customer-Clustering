# -*- coding: utf-8 -*-
"""Clustering.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1eOKXr4aEGlXpUcUeP2_iPKAbVO0kR3Y8
"""

import numpy as np
import pandas as pd
import seaborn as sb
import matplotlib.pyplot as plt
import math
data = pd.read_csv('Mall_Customers.csv')
data

# lets make Genre numerical. You can also make it dummy
data['Genre'] = data.Genre.map({'Female':0, 'Male':1})
data.head()

data = data.drop('CustomerID', axis=1)

data

#Visualiztion
sb.heatmap(data.corr(), annot = True)
plt.show()

#NOW COMPARE BETWEEN EVERY COLUMNS
#Gender
print(data[data['Genre'].isna() == True])
print(data.groupby('Genre').count()['Spending Score (1-100)'])
sb.countplot(data['Genre'], data = data)
sb.catplot(x="Genre", y="Age",kind = 'swarm', data=data)
sb.catplot(x = "Genre", y = "Annual Income (k$)",data = data)
sb.catplot(x = "Genre", y = "Spending Score (1-100)", data = data)

#AGE
print(data[data['Age'].isna() == True])
plt.subplot(2, 1, 1)
plt.scatter(data['Age'], data['Spending Score (1-100)'])
plt.xlabel("Age")
plt.ylabel('Spending Score')
plt.subplot(2, 1, 2)
plt.scatter(data['Age'], data['Annual Income (k$)'])
plt.xlabel("Age")
plt.ylabel('Income')
plt.show()

#INCOME AND SCORE
plt.scatter(data['Spending Score (1-100)'], data['Annual Income (k$)'])
plt.xlabel("Score")
plt.ylabel('Income')
plt.show()

y = data['Spending Score (1-100)']
data = data.drop('Spending Score (1-100)', axis=1)
X = np.array(data)
Y = np.array(y)

from sklearn.model_selection import train_test_split
X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.2)

K = 3
def random_intialize(K, X):
    m = len(X)
    idx = []
    for i in range(K):
        idx.append(X[i])
    idx = np.array(idx)
    return idx
mu = random_intialize(K, X)
print(mu)

def dist(a,b):
    return np.linalg.norm(a-b, axis=0)
def cost_fuction(X, mu):
    #for point in X:
    point = X
    distances = []
    for index in range(len(mu)):
        distances.append(dist(point,mu[index]))
    return distances
def cluster_assign(X, mu):
    classes = {}
    for j in range(len(mu)):
        classes[j] = []
    for point in X:
        distances = cost_fuction(point, mu)
        cluster_index = distances.index(min(distances))
        classes[cluster_index].append(point)
    return classes
def move_centroid(mu, X, classes):
    for cluster_index in classes:
        mu[cluster_index] = np.average(classes[cluster_index], axis = 0)
    return mu

for x in range(0,501): 
    c = cluster_assign(X, mu)
    mu = move_centroid(mu, X, c)

print(mu)

colors = 10*["r", "g", "c", "b", "k"]

for m in range(len(mu)):
    plt.scatter(mu[m][1], mu[m][2],marker = "x", s = 130)
for ca in c:
    color = colors[ca]
    for f in c[ca]:
        plt.scatter(f[1], f[2], color = color, s = 30)

